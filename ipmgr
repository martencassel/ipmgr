#!/usr/bin/env bash

STATE_FILE="$HOME/.ipmgr_state"
CONFIG_FILE="./ipmgr.yaml"

# Colors
RESET='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
BG_BLUE='\033[44m'
BG_GREEN='\033[42m'

# Ensure state file exists
touch "$STATE_FILE"

# Helper: check if yq is available
check_yq() {
  if ! command -v yq &>/dev/null; then
    echo -e "${RED}✗${RESET} yq is required for YAML config files"
    echo -e "${DIM}Install with:${RESET}"
    echo -e "  ${CYAN}brew install yq${RESET} (macOS)"
    echo -e "  ${CYAN}snap install yq${RESET} (Linux)"
    echo -e "  ${CYAN}wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/local/bin/yq && chmod +x /usr/local/bin/yq${RESET}"
    exit 1
  fi
}

# Helper: parse YAML config and apply IPs
apply_config() {
  local config_file=${1:-$CONFIG_FILE}

  if [ ! -f "$config_file" ]; then
    echo -e "${RED}✗${RESET} Config file not found: ${YELLOW}${config_file}${RESET}"
    exit 1
  fi

  check_yq

  echo -e "${BOLD}${BLUE}Applying configuration from ${YELLOW}${config_file}${RESET}"
  echo ""

  # Read interfaces from YAML
  local iface_count=$(yq eval '.interfaces | length' "$config_file")

  if [ "$iface_count" -eq 0 ]; then
    echo -e "${YELLOW}⚠${RESET} No interfaces defined in config"
    exit 0
  fi

  local applied=0
  local skipped=0
  local failed=0

  # Process each interface
  for ((i=0; i<iface_count; i++)); do
    local iface=$(yq eval ".interfaces[$i].name" "$config_file")
    local ip_count=$(yq eval ".interfaces[$i].ips | length" "$config_file")

    echo -e "${BOLD}${BLUE}Interface: ${YELLOW}${iface}${RESET}"

    # Validate interface exists
    if ! ip link show "$iface" &>/dev/null; then
      echo -e "  ${RED}✗${RESET} Interface does not exist, skipping"
      failed=$((failed + ip_count))
      echo ""
      continue
    fi

    # Process each IP
    for ((j=0; j<ip_count; j++)); do
      local ip=$(yq eval ".interfaces[$i].ips[$j]" "$config_file")

      # Check if already allocated
      if grep -q "^$iface $ip$" "$STATE_FILE"; then
        echo -e "  ${DIM}○${RESET} ${CYAN}${ip}${RESET} ${DIM}(already allocated)${RESET}"
        skipped=$((skipped+1))
      else
        # Try to add IP
        if sudo ip addr add "$ip/32" dev "$iface" 2>/dev/null; then
          echo "$iface $ip" >> "$STATE_FILE"
          echo -e "  ${GREEN}✓${RESET} ${CYAN}${ip}${RESET} allocated"
          applied=$((applied+1))
        else
          echo -e "  ${RED}✗${RESET} ${CYAN}${ip}${RESET} failed to allocate"
          failed=$((failed+1))
        fi
      fi
    done
    echo ""
  done

  # Summary
  echo -e "${DIM}═══════════════════════════════${RESET}"
  echo -e "${BOLD}Summary:${RESET} ${GREEN}${applied}${RESET} applied, ${YELLOW}${skipped}${RESET} skipped, ${RED}${failed}${RESET} failed"
  echo ""
}

# Helper: generate YAML config from current state
generate_config() {
  local config_file=${1:-$CONFIG_FILE}

  if [ -f "$config_file" ]; then
    echo -e "${YELLOW}⚠${RESET} Config file already exists: ${YELLOW}${config_file}${RESET}"
    read -p "Overwrite? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${DIM}Cancelled${RESET}"
      exit 0
    fi
  fi

  if [ ! -s "$STATE_FILE" ]; then
    echo -e "${YELLOW}⚠${RESET} No allocations found in state file"
    echo -e "${DIM}Creating empty config template...${RESET}"
    cat > "$config_file" << 'EOF'
# ipmgr configuration file
# Define desired IP allocations per interface

interfaces:
  - name: eth0
    ips:
      - 192.168.1.10
      - 192.168.1.11

  # - name: docker0
  #   ips:
  #     - 172.17.0.10
  #     - 172.17.0.11
EOF
    echo -e "${GREEN}✓${RESET} Created template config: ${CYAN}${config_file}${RESET}"
    return
  fi

  # Generate YAML from state file
  {
    echo "# ipmgr configuration file"
    echo "# Generated from current state on $(date)"
    echo ""
    echo "interfaces:"

    # Get unique interfaces
    local ifaces=$(awk '{print $1}' "$STATE_FILE" | sort -u)

    while IFS= read -r iface; do
      echo "  - name: $iface"
      echo "    ips:"

      grep "^$iface " "$STATE_FILE" | while read -r _ ip; do
        echo "      - $ip"
      done
    done <<< "$ifaces"
  } > "$config_file"

  echo -e "${GREEN}✓${RESET} Generated config: ${CYAN}${config_file}${RESET}"

  # Show summary
  local iface_count=$(echo "$ifaces" | wc -l)
  local ip_count=$(wc -l < "$STATE_FILE")
  echo -e "${DIM}  ${iface_count} interface(s), ${ip_count} IP(s)${RESET}"
}

# Helper: validate YAML config file
validate_config() {
  local config_file=${1:-$CONFIG_FILE}

  if [ ! -f "$config_file" ]; then
    echo -e "${RED}✗${RESET} Config file not found: ${YELLOW}${config_file}${RESET}"
    exit 1
  fi

  check_yq

  echo -e "${BOLD}${BLUE}Validating ${YELLOW}${config_file}${RESET}"
  echo ""

  # Check YAML syntax
  if ! yq eval '.' "$config_file" >/dev/null 2>&1; then
    echo -e "${RED}✗${RESET} Invalid YAML syntax"
    exit 1
  fi

  echo -e "${GREEN}✓${RESET} YAML syntax valid"

  # Check structure
  local iface_count=$(yq eval '.interfaces | length' "$config_file")

  if [ "$iface_count" -eq 0 ]; then
    echo -e "${YELLOW}⚠${RESET} No interfaces defined"
    exit 0
  fi

  echo -e "${GREEN}✓${RESET} Found ${CYAN}${iface_count}${RESET} interface(s)"
  echo ""

  local total_ips=0
  local issues=0

  # Validate each interface
  for ((i=0; i<iface_count; i++)); do
    local iface=$(yq eval ".interfaces[$i].name" "$config_file")
    local ip_count=$(yq eval ".interfaces[$i].ips | length" "$config_file")
    total_ips=$((total_ips + ip_count))

    echo -e "${BOLD}${BLUE}Interface: ${YELLOW}${iface}${RESET}"

    # Check if interface exists
    if ! ip link show "$iface" &>/dev/null; then
      echo -e "  ${RED}✗${RESET} Interface does not exist"
      issues=$((issues+1))
    else
      echo -e "  ${GREEN}✓${RESET} Interface exists"
    fi

    # Validate IPs
    echo -e "  ${CYAN}${ip_count}${RESET} IP(s) defined"

    for ((j=0; j<ip_count; j++)); do
      local ip=$(yq eval ".interfaces[$i].ips[$j]" "$config_file")

      # Basic IP format validation
      if [[ ! $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        echo -e "    ${RED}✗${RESET} Invalid IP format: ${CYAN}${ip}${RESET}"
        issues=$((issues+1))
      fi
    done
    echo ""
  done

  # Summary
  echo -e "${DIM}═══════════════════════════════${RESET}"
  if [ "$issues" -eq 0 ]; then
    echo -e "${BOLD}${GREEN}✓ Validation passed${RESET}"
    echo -e "  ${CYAN}${iface_count}${RESET} interface(s), ${CYAN}${total_ips}${RESET} IP(s) defined"
  else
    echo -e "${BOLD}${RED}✗ Validation failed${RESET}"
    echo -e "  ${RED}${issues}${RESET} issue(s) found"
    exit 1
  fi
  echo ""
}

# Helper: show diff between config and current state
diff_config() {
  local config_file=${1:-$CONFIG_FILE}

  if [ ! -f "$config_file" ]; then
    echo -e "${RED}✗${RESET} Config file not found: ${YELLOW}${config_file}${RESET}"
    exit 1
  fi

  check_yq

  echo -e "${BOLD}${BLUE}Configuration Diff${RESET}"
  echo -e "${DIM}Shows what would change if config is applied${RESET}"
  echo ""

  local iface_count=$(yq eval '.interfaces | length' "$config_file")
  local to_add=0
  local already_present=0
  local to_remove=0

  # Check what would be added
  for ((i=0; i<iface_count; i++)); do
    local iface=$(yq eval ".interfaces[$i].name" "$config_file")
    local ip_count=$(yq eval ".interfaces[$i].ips | length" "$config_file")

    for ((j=0; j<ip_count; j++)); do
      local ip=$(yq eval ".interfaces[$i].ips[$j]" "$config_file")

      if grep -q "^$iface $ip$" "$STATE_FILE"; then
        already_present=$((already_present+1))
      else
        if [ "$to_add" -eq 0 ]; then
          echo -e "${BOLD}${GREEN}To be added:${RESET}"
        fi
        echo -e "  ${GREEN}+${RESET} ${YELLOW}${iface}${RESET} ${CYAN}${ip}${RESET}"
        to_add=$((to_add+1))
      fi
    done
  done

  if [ "$to_add" -gt 0 ]; then
    echo ""
  fi

  # Check what would be removed (IPs in state but not in config)
  while read -r iface ip; do
    # Check if this IP is in the config
    local found=false
    for ((i=0; i<iface_count; i++)); do
      local cfg_iface=$(yq eval ".interfaces[$i].name" "$config_file")
      if [ "$cfg_iface" = "$iface" ]; then
        local ip_count=$(yq eval ".interfaces[$i].ips | length" "$config_file")
        for ((j=0; j<ip_count; j++)); do
          local cfg_ip=$(yq eval ".interfaces[$i].ips[$j]" "$config_file")
          if [ "$cfg_ip" = "$ip" ]; then
            found=true
            break 2
          fi
        done
      fi
    done

    if [ "$found" = false ]; then
      if [ "$to_remove" -eq 0 ]; then
        echo -e "${BOLD}${YELLOW}Not in config (would remain):${RESET}"
      fi
      echo -e "  ${DIM}○${RESET} ${YELLOW}${iface}${RESET} ${CYAN}${ip}${RESET}"
      to_remove=$((to_remove+1))
    fi
  done < "$STATE_FILE"

  if [ "$to_remove" -gt 0 ]; then
    echo ""
  fi

  # Summary
  echo -e "${DIM}═══════════════════════════════${RESET}"
  echo -e "${BOLD}Summary:${RESET}"
  echo -e "  ${GREEN}${to_add}${RESET} to be added"
  echo -e "  ${CYAN}${already_present}${RESET} already present"
  echo -e "  ${YELLOW}${to_remove}${RESET} not in config"
  echo ""
}

# Helper: validate interface exists
validate_iface() {
  local iface=$1
  if ! ip link show "$iface" &>/dev/null; then
    echo -e "${RED}✗${RESET} Interface ${YELLOW}${iface}${RESET} does not exist"
    echo -e "${DIM}Available interfaces:${RESET}"
    ip -br link show | awk '{print "  " $1}' | grep -v "^  lo$"
    exit 1
  fi
}

# Helper: get interface subnet
get_iface_subnet() {
  local iface=$1
  # Get the first IPv4 address and its CIDR
  ip -4 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet\s)\d+\.\d+\.\d+\.\d+/\d+' | head -1
}

# Helper: check if IP is in subnet
ip_in_subnet() {
  local ip=$1
  local subnet=$2

  if [ -z "$subnet" ]; then
    return 1
  fi

  # Extract network and mask
  local network=$(echo "$subnet" | cut -d/ -f1)
  local mask=$(echo "$subnet" | cut -d/ -f2)

  # Convert IP to integer
  local IFS=.
  read -r i1 i2 i3 i4 <<< "$ip"
  local ip_int=$((i1 * 256**3 + i2 * 256**2 + i3 * 256 + i4))

  # Convert network to integer
  read -r n1 n2 n3 n4 <<< "$network"
  local net_int=$((n1 * 256**3 + n2 * 256**2 + n3 * 256 + n4))

  # Calculate network mask
  local mask_int=$(( (0xFFFFFFFF << (32 - mask)) & 0xFFFFFFFF ))

  # Check if IP is in subnet
  if [ $(( ip_int & mask_int )) -eq $(( net_int & mask_int )) ]; then
    return 0
  fi
  return 1
}

# Helper: suggest valid pool range
suggest_pool_range() {
  local iface=$1
  local subnet=$(get_iface_subnet "$iface")

  if [ -z "$subnet" ]; then
    echo -e "${YELLOW}⚠${RESET}  No IP configured on ${YELLOW}${iface}${RESET}"
    echo -e "${DIM}  Configure an IP first or use a different interface${RESET}"
    return
  fi

  local network=$(echo "$subnet" | cut -d/ -f1)
  local mask=$(echo "$subnet" | cut -d/ -f2)

  # Calculate network address and broadcast
  IFS=. read -r n1 n2 n3 n4 <<< "$network"
  local net_int=$((n1 * 256**3 + n2 * 256**2 + n3 * 256 + n4))
  local mask_int=$(( (0xFFFFFFFF << (32 - mask)) & 0xFFFFFFFF ))
  local network_addr=$(( net_int & mask_int ))
  local broadcast_addr=$(( network_addr | ~mask_int & 0xFFFFFFFF ))

  # Convert back to dotted notation
  local net_n1=$(( (network_addr >> 24) & 0xFF ))
  local net_n2=$(( (network_addr >> 16) & 0xFF ))
  local net_n3=$(( (network_addr >> 8) & 0xFF ))
  local net_n4=$(( network_addr & 0xFF ))

  local bcast_n1=$(( (broadcast_addr >> 24) & 0xFF ))
  local bcast_n2=$(( (broadcast_addr >> 16) & 0xFF ))
  local bcast_n3=$(( (broadcast_addr >> 8) & 0xFF ))
  local bcast_n4=$(( broadcast_addr & 0xFF ))

  # Suggest a safe range (avoid network and broadcast addresses)
  local start_ip="$net_n1.$net_n2.$net_n3.$((net_n4 + 10))"
  local end_ip="$bcast_n1.$bcast_n2.$bcast_n3.$((bcast_n4 - 1))"

  echo -e "${DIM}Interface subnet:${RESET} ${CYAN}${subnet}${RESET}"
  echo -e "${DIM}Suggested pool:${RESET}   ${GREEN}${start_ip}-${end_ip}${RESET}"
}

usage() {
  echo -e ""
  echo -e "${BOLD}${BG_BLUE}${WHITE}  ipmgr - IP Address Manager  ${RESET}"
  echo -e ""
  echo -e "${BOLD}${BLUE}USAGE:${RESET}"
  echo -e "  ${BOLD}ipmgr${RESET} ${GREEN}<command>${RESET} ${CYAN}[options]${RESET}"
  echo -e ""
  echo -e "${BOLD}${BLUE}COMMANDS:${RESET}"
  echo -e "  ${GREEN}alloc${RESET}           Allocate next free IP from a pool"
  echo -e "                  ${CYAN}--pool${RESET} ${YELLOW}<start-end>${RESET}  IP range (e.g., 192.168.1.10-192.168.1.20)"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface (e.g., eth0)"
  echo -e ""
  echo -e "  ${GREEN}add${RESET}             Add a specific IP to an interface"
  echo -e "                  ${YELLOW}<ip>${RESET}              IP address to add"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface"
  echo -e ""
  echo -e "  ${GREEN}release${RESET}         Release an IP from an interface"
  echo -e "                  ${YELLOW}<ip>${RESET}              IP address to release"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface"
  echo -e ""
  echo -e "  ${GREEN}list${RESET}            List IPs for a specific interface"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface"
  echo -e ""
  echo -e "  ${GREEN}list-all${RESET}        List all IPs grouped by interface"
  echo -e ""
  echo -e "  ${GREEN}show-iface${RESET}      Show interface details and subnet information"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface"
  echo -e ""
  echo -e "  ${GREEN}render-env${RESET}      Export IPs as environment variables"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface"
  echo -e "                  ${CYAN}--prefix${RESET} ${YELLOW}<PREFIX>${RESET}    Variable prefix (default: IPMGR)"
  echo -e ""
  echo -e "  ${GREEN}sync${RESET}            Re-apply missing IPs from state file"
  echo -e "                  ${DIM}Ensures system interfaces match allocations in state file${RESET}"
  echo -e ""
  echo -e "  ${GREEN}delete-pool${RESET}     Delete all IPs in a pool"
  echo -e "                  ${CYAN}--pool${RESET} ${YELLOW}<start-end>${RESET}  IP range"
  echo -e "                  ${CYAN}--iface${RESET} ${YELLOW}<iface>${RESET}      Network interface"
  echo -e ""
  echo -e "  ${GREEN}cleanup${RESET}         Remove all allocations and clear state file"
  echo -e ""
  echo -e "${BOLD}${BLUE}DECLARATIVE CONFIG:${RESET}"
  echo -e "  ${GREEN}apply${RESET}           Apply IP allocations from YAML config file"
  echo -e "                  ${CYAN}--config${RESET} ${YELLOW}<file>${RESET}   Config file (default: ./ipmgr.yaml)"
  echo -e ""
  echo -e "  ${GREEN}generate${RESET}        Generate YAML config from current state"
  echo -e "                  ${CYAN}--config${RESET} ${YELLOW}<file>${RESET}   Output file (default: ./ipmgr.yaml)"
  echo -e ""
  echo -e "  ${GREEN}validate${RESET}        Validate YAML config file syntax and structure"
  echo -e "                  ${CYAN}--config${RESET} ${YELLOW}<file>${RESET}   Config file (default: ./ipmgr.yaml)"
  echo -e ""
  echo -e "  ${GREEN}diff${RESET}            Show differences between config and current state"
  echo -e "                  ${CYAN}--config${RESET} ${YELLOW}<file>${RESET}   Config file (default: ./ipmgr.yaml)"
  echo -e ""
  echo -e "${BOLD}${BLUE}EXAMPLES:${RESET}"
  echo -e "  ${DIM}# Allocate next free IP from pool${RESET}"
  echo -e "  \$ ipmgr alloc --pool 192.168.1.10-192.168.1.20 --iface eth0"
  echo -e ""
  echo -e "  ${DIM}# Add specific IP${RESET}"
  echo -e "  \$ ipmgr add 10.0.0.5 --iface eth1"
  echo -e ""
  echo -e "  ${DIM}# List all allocations${RESET}"
  echo -e "  \$ ipmgr list-all"
  echo -e ""
  echo -e "  ${DIM}# Show interface details and suggested pool${RESET}"
  echo -e "  \$ ipmgr show-iface --iface docker0"
  echo -e ""
  echo -e "  ${DIM}# Release an IP${RESET}"
  echo -e "  \$ ipmgr release 192.168.1.10 --iface eth0"
  echo -e ""
  echo -e "  ${DIM}# Export as env vars${RESET}"
  echo -e "  \$ eval \$(ipmgr render-env --iface eth0 --prefix MYAPP)"
  echo -e ""
  echo -e "  ${DIM}# Sync state with system${RESET}"
  echo -e "  \$ ipmgr sync"
  echo -e ""
  echo -e "  ${DIM}# Delete a pool${RESET}"
  echo -e "  \$ ipmgr delete-pool --pool 192.168.1.10-192.168.1.20 --iface eth0"
  echo -e ""
  echo -e "  ${DIM}# Cleanup everything${RESET}"
  echo -e "  \$ ipmgr cleanup"
  echo -e ""
  echo -e "  ${DIM}# Generate config from current state${RESET}"
  echo -e "  \$ ipmgr generate"
  echo -e ""
  echo -e "  ${DIM}# Apply config file${RESET}"
  echo -e "  \$ ipmgr apply --config ipmgr.yaml"
  echo -e ""
  echo -e "  ${DIM}# Show what would change${RESET}"
  echo -e "  \$ ipmgr diff"
  echo -e ""
  echo -e "${BOLD}${BLUE}FILES:${RESET}"
  echo -e "  ${DIM}Config file:${RESET} ${CYAN}./ipmgr.yaml${RESET}"
  echo -e "  ${DIM}State file:${RESET} ${CYAN}~/.ipmgr_state${RESET}"
  echo -e ""
  exit 1
}

# Helper: delete all IPs in a pool
delete_pool() {
  local pool=$1
  local iface=$2
  validate_iface "$iface"
  local start=$(echo "$pool" | cut -d- -f1)
  local end=$(echo "$pool" | cut -d- -f2)

  IFS=. read -r s1 s2 s3 s4 <<< "$start"
  IFS=. read -r e1 e2 e3 e4 <<< "$end"

  local deleted=0
  for ((i=s4; i<=e4; i++)); do
    candidate="$s1.$s2.$s3.$i"
    if grep -q "^$iface $candidate$" "$STATE_FILE"; then
      sudo ip addr del "$candidate/32" dev "$iface"
      sed -i "/^$iface $candidate$/d" "$STATE_FILE"
      echo -e "${GREEN}✓${RESET} Deleted ${CYAN}${candidate}${RESET} from ${YELLOW}${iface}${RESET}"
      deleted=$((deleted+1))
    fi
  done

  if [ "$deleted" -eq 0 ]; then
    echo -e "${RED}✗${RESET} No IPs from pool ${MAGENTA}${pool}${RESET} found on ${YELLOW}${iface}${RESET}"
  fi
}

# Helper: cleanup all allocations
cleanup_all() {
  if [ ! -s "$STATE_FILE" ]; then
    echo -e "${DIM}No allocations to cleanup${RESET}"
    return
  fi

  while read -r iface ip; do
    sudo ip addr del "$ip/32" dev "$iface" 2>/dev/null
    echo -e "${GREEN}✓${RESET} Removed ${CYAN}${ip}${RESET} from ${YELLOW}${iface}${RESET}"
  done < "$STATE_FILE"

  > "$STATE_FILE"
  echo -e "${BOLD}${RED}All allocations cleared${RESET}"
}




# Helper: add IP to iface
add_ip() {
  local ip=$1
  local iface=$2
  local skip_validation=${3:-false}
  validate_iface "$iface"

  # Validate IP is in subnet unless skipped
  if [ "$skip_validation" != "true" ]; then
    local subnet=$(get_iface_subnet "$iface")
    if [ -n "$subnet" ] && ! ip_in_subnet "$ip" "$subnet"; then
      echo -e "${RED}✗${RESET} IP ${CYAN}${ip}${RESET} is not in the subnet of ${YELLOW}${iface}${RESET}"
      echo -e ""
      suggest_pool_range "$iface"
      return 1
    fi
  fi

  sudo ip addr add "$ip/32" dev "$iface" 2>/dev/null
  if [ $? -ne 0 ]; then
    echo -e "${RED}✗${RESET} Failed to add ${CYAN}${ip}${RESET} to ${YELLOW}${iface}${RESET} (may already exist)"
    return 1
  fi

  echo "$iface $ip" >> "$STATE_FILE"
  echo -e "${GREEN}✓${RESET} Allocated ${CYAN}${ip}${RESET} on ${YELLOW}${iface}${RESET}"
}

# Helper: release IP from iface
release_ip() {
  local ip=$1
  local iface=$2
  validate_iface "$iface"
  sudo ip addr del "$ip/32" dev "$iface"
  sed -i "/^$iface $ip$/d" "$STATE_FILE"
  echo -e "${GREEN}✓${RESET} Released ${CYAN}${ip}${RESET} from ${YELLOW}${iface}${RESET}"
}

# Helper: allocate next free IP from pool
alloc_ip() {
  local pool=$1
  local iface=$2
  validate_iface "$iface"
  local start=$(echo "$pool" | cut -d- -f1)
  local end=$(echo "$pool" | cut -d- -f2)

  # Validate pool is in subnet
  local subnet=$(get_iface_subnet "$iface")
  if [ -n "$subnet" ]; then
    if ! ip_in_subnet "$start" "$subnet" || ! ip_in_subnet "$end" "$subnet"; then
      echo -e "${RED}✗${RESET} Pool ${MAGENTA}${pool}${RESET} is not in the subnet of ${YELLOW}${iface}${RESET}"
      echo -e ""
      suggest_pool_range "$iface"
      return 1
    fi
  fi

  IFS=. read -r s1 s2 s3 s4 <<< "$start"
  IFS=. read -r e1 e2 e3 e4 <<< "$end"

  for ((i=s4; i<=e4; i++)); do
    candidate="$s1.$s2.$s3.$i"
    if ! grep -q "$iface $candidate" "$STATE_FILE"; then
      add_ip "$candidate" "$iface" true  # Skip validation since we already validated the pool
      return
    fi
  done
  echo -e "${RED}✗${RESET} No free IPs in pool ${MAGENTA}${pool}${RESET}"
}

# Helper: list allocations
list_ips() {
  local iface=$1
  local ips=$(grep "^$iface " "$STATE_FILE")

  if [ -z "$ips" ]; then
    echo -e "${DIM}No allocations for ${YELLOW}${iface}${RESET}"
    return
  fi

  echo -e "${BOLD}${BLUE}Interface: ${YELLOW}${iface}${RESET}"
  echo -e "${DIM}────────────────────────────${RESET}"
  echo "$ips" | awk -v cyan="$CYAN" -v reset="$RESET" '{printf "  %s%s%s\n", cyan, $2, reset}'
  local count=$(echo "$ips" | wc -l)
  echo -e "${DIM}  (${count} IP(s) allocated)${RESET}"
}

# Helper: show interface details
show_iface() {
  local iface=$1
  validate_iface "$iface"

  echo ""
  echo -e "${BOLD}${BG_BLUE}${WHITE}  Interface Details: ${YELLOW}${iface}${RESET}${WHITE}  ${RESET}"
  echo ""

  # Get interface status
  local status=$(ip -br link show "$iface" | awk '{print $2}')
  local status_color=$GREEN
  if [ "$status" != "UP" ]; then
    status_color=$RED
  fi

  echo -e "${BOLD}${BLUE}Status:${RESET} ${status_color}${status}${RESET}"
  echo ""

  # Get all IP addresses
  local ip_info=$(ip -4 addr show "$iface" 2>/dev/null | grep "inet ")

  if [ -z "$ip_info" ]; then
    echo -e "${YELLOW}⚠${RESET}  ${DIM}No IPv4 addresses configured${RESET}"
    echo ""
    echo -e "${DIM}To add an IP address:${RESET}"
    echo -e "  ${CYAN}sudo ip addr add <ip>/<mask> dev ${iface}${RESET}"
    echo ""
  else
    echo -e "${BOLD}${BLUE}Configured Subnets:${RESET}"
    echo ""

    while IFS= read -r line; do
      local cidr=$(echo "$line" | grep -oP '(?<=inet\\s)\\d+\\.\\d+\\.\\d+\\.\\d+/\\d+')
      local scope=$(echo "$line" | grep -oP '(?<=scope\\s)\\w+')

      if [ -n "$cidr" ]; then
        local ip=$(echo "$cidr" | cut -d/ -f1)
        local mask=$(echo "$cidr" | cut -d/ -f2)
        echo -e "  ${CYAN}${cidr}${RESET} ${DIM}(scope: ${scope})${RESET}"

        # Calculate usable range
        IFS=. read -r n1 n2 n3 n4 <<< "$ip"
        local net_int=$((n1 * 256**3 + n2 * 256**2 + n3 * 256 + n4))
        local mask_int=$(( (0xFFFFFFFF << (32 - mask)) & 0xFFFFFFFF ))
        local network_addr=$(( net_int & mask_int ))
        local broadcast_addr=$(( network_addr | ~mask_int & 0xFFFFFFFF ))

        local net_n1=$(( (network_addr >> 24) & 0xFF ))
        local net_n2=$(( (network_addr >> 16) & 0xFF ))
        local net_n3=$(( (network_addr >> 8) & 0xFF ))
        local net_n4=$(( network_addr & 0xFF ))

        local bcast_n1=$(( (broadcast_addr >> 24) & 0xFF ))
        local bcast_n2=$(( (broadcast_addr >> 16) & 0xFF ))
        local bcast_n3=$(( (broadcast_addr >> 8) & 0xFF ))
        local bcast_n4=$(( broadcast_addr & 0xFF ))

        local num_hosts=$(( (1 << (32 - mask)) - 2 ))

        echo -e "  ${DIM}├─ Network:   ${net_n1}.${net_n2}.${net_n3}.${net_n4}${RESET}"
        echo -e "  ${DIM}├─ Broadcast: ${bcast_n1}.${bcast_n2}.${bcast_n3}.${bcast_n4}${RESET}"
        echo -e "  ${DIM}└─ Usable:    ~${num_hosts} hosts${RESET}"
        echo ""
      fi
    done <<< "$ip_info"

    # Suggest pool range
    echo -e "${BOLD}${BLUE}Suggested Pool Range:${RESET}"
    echo ""
    local subnet=$(get_iface_subnet "$iface")
    if [ -n "$subnet" ]; then
      local network=$(echo "$subnet" | cut -d/ -f1)
      local mask=$(echo "$subnet" | cut -d/ -f2)

      IFS=. read -r n1 n2 n3 n4 <<< "$network"
      local net_int=$((n1 * 256**3 + n2 * 256**2 + n3 * 256 + n4))
      local mask_int=$(( (0xFFFFFFFF << (32 - mask)) & 0xFFFFFFFF ))
      local network_addr=$(( net_int & mask_int ))
      local broadcast_addr=$(( network_addr | ~mask_int & 0xFFFFFFFF ))

      local net_n1=$(( (network_addr >> 24) & 0xFF ))
      local net_n2=$(( (network_addr >> 16) & 0xFF ))
      local net_n3=$(( (network_addr >> 8) & 0xFF ))
      local net_n4=$(( network_addr & 0xFF ))

      local bcast_n1=$(( (broadcast_addr >> 24) & 0xFF ))
      local bcast_n2=$(( (broadcast_addr >> 16) & 0xFF ))
      local bcast_n3=$(( (broadcast_addr >> 8) & 0xFF ))
      local bcast_n4=$(( broadcast_addr & 0xFF ))

      local start_ip="$net_n1.$net_n2.$net_n3.$((net_n4 + 10))"
      local end_ip="$bcast_n1.$bcast_n2.$bcast_n3.$((bcast_n4 - 1))"

      echo -e "  ${GREEN}${start_ip}-${end_ip}${RESET}"
      echo ""
      echo -e "${DIM}Example usage:${RESET}"
      echo -e "  ${CYAN}ipmgr alloc --pool ${start_ip}-${end_ip} --iface ${iface}${RESET}"
    fi
  fi

  # Show current allocations from ipmgr
  local allocated=$(grep "^$iface " "$STATE_FILE" 2>/dev/null)
  if [ -n "$allocated" ]; then
    echo ""
    echo -e "${BOLD}${BLUE}Current ipmgr Allocations:${RESET}"
    echo ""
    echo "$allocated" | awk -v cyan="$CYAN" -v reset="$RESET" '{printf "  %s%s%s\n", cyan, $2, reset}'
    local count=$(echo "$allocated" | wc -l)
    echo -e "${DIM}  (${count} IP(s) allocated)${RESET}"
  fi

  echo ""
}

# Helper: list all allocations grouped by interface
list_all_ips() {
  if [ ! -s "$STATE_FILE" ]; then
    echo -e "${DIM}No allocations found${RESET}"
    return
  fi

  # Get unique interfaces
  local ifaces=$(awk '{print $1}' "$STATE_FILE" | sort -u)

  if [ -z "$ifaces" ]; then
    echo -e "${DIM}No allocations found${RESET}"
    return
  fi

  # Header
  echo ""
  echo -e "${BOLD}${BG_BLUE}${WHITE}  IP Allocations by Interface  ${RESET}"
  echo ""

  local total_ips=0
  local iface_count=0

  while IFS= read -r iface; do
    ((iface_count++))
    echo -e "${BOLD}${BLUE}┌─ Interface: ${YELLOW}${iface}${RESET}"

    local ips=$(grep "^$iface " "$STATE_FILE")
    local count=$(echo "$ips" | wc -l)
    total_ips=$((total_ips + count))

    echo "$ips" | awk -v cyan="$CYAN" -v reset="$RESET" -v blue="$BLUE" '{printf "%s│%s  %s%s%s\n", blue, reset, cyan, $2, reset}'

    echo -e "${BLUE}└─${RESET} ${DIM}${count} IP(s)${RESET}"
    echo ""
  done <<< "$ifaces"

  # Footer summary
  echo -e "${DIM}═══════════════════════════════${RESET}"
  echo -e "${BOLD}Summary:${RESET} ${GREEN}${iface_count}${RESET} interface(s), ${GREEN}${total_ips}${RESET} IP(s) total"
  echo ""
}

# Helper: render allocations as env vars
render_env() {
  local iface=$1
  local prefix=${2:-IPMGR}
  local i=1

  while read -r line; do
    ip=$(echo "$line" | awk '{print $2}')
    echo "${prefix}_IP${i}=$ip"
    ((i++))
  done < <(grep "^$iface " "$STATE_FILE")
}

# Helper: sync state file with actual system IPs
sync_ips() {
  local synced=0

  # Loop through each entry in state file
  while read -r iface ip; do
    # Check if IP is actually assigned
    if ! ip addr show dev "$iface" | grep -qw "$ip"; then
      echo -e "${YELLOW}↺${RESET} Re-applying ${CYAN}${ip}${RESET} to ${YELLOW}${iface}${RESET}"
      sudo ip addr add "$ip/32" dev "$iface"
      synced=$((synced+1))
    fi
  done < "$STATE_FILE"

  # Optionally: detect IPs on system but not in state file
  for iface in $(awk '{print $1}' "$STATE_FILE" | sort -u); do
    ip addr show dev "$iface" | grep -oP '(?<=inet )\d+\.\d+\.\d+\.\d+' | while read -r ip; do
      if ! grep -q "^$iface $ip$" "$STATE_FILE"; then
        echo -e "${MAGENTA}⚠${RESET} Found ${CYAN}${ip}${RESET} on ${YELLOW}${iface}${RESET} not in state file"
        # Uncomment to auto-add:
        # echo "$iface $ip" >> "$STATE_FILE"
      fi
    done
  done

  if [ "$synced" -eq 0 ]; then
    echo -e "${GREEN}✓${RESET} All IPs are in sync"
  fi
}


# Parse command
cmd=$1
shift

case "$cmd" in
  alloc)
    while [[ $# -gt 0 ]]; do
      case $1 in
        --pool) pool=$2; shift 2 ;;
        --iface) iface=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$pool" || -z "$iface" ]] && usage
    alloc_ip "$pool" "$iface"
    ;;
  add)
    ip=$1; shift
    while [[ $# -gt 0 ]]; do
      case $1 in
        --iface) iface=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$ip" || -z "$iface" ]] && usage
    add_ip "$ip" "$iface"
    ;;
  release)
    ip=$1; shift
    while [[ $# -gt 0 ]]; do
      case $1 in
        --iface) iface=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$ip" || -z "$iface" ]] && usage
    release_ip "$ip" "$iface"
    ;;
  list)
    while [[ $# -gt 0 ]]; do
      case $1 in
        --iface) iface=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$iface" ]] && usage
    list_ips "$iface"
    ;;
  list-all)
    list_all_ips
    ;;
  show-iface)
    while [[ $# -gt 0 ]]; do
      case $1 in
        --iface) iface=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$iface" ]] && usage
    show_iface "$iface"
    ;;
  sync)
    sync_ips
    ;;
  delete-pool)
    while [[ $# -gt 0 ]]; do
      case $1 in
        --pool) pool=$2; shift 2 ;;
        --iface) iface=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$pool" || -z "$iface" ]] && usage
    delete_pool "$pool" "$iface"
    ;;
  cleanup)
    cleanup_all
    ;;
  render-env)
    while [[ $# -gt 0 ]]; do
      case $1 in
        --iface) iface=$2; shift 2 ;;
        --prefix) prefix=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    [[ -z "$iface" ]] && usage
    render_env "$iface" "$prefix"
    ;;
  apply)
    config_file="$CONFIG_FILE"
    while [[ $# -gt 0 ]]; do
      case $1 in
        --config) config_file=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    apply_config "$config_file"
    ;;
  generate)
    config_file="$CONFIG_FILE"
    while [[ $# -gt 0 ]]; do
      case $1 in
        --config) config_file=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    generate_config "$config_file"
    ;;
  validate)
    config_file="$CONFIG_FILE"
    while [[ $# -gt 0 ]]; do
      case $1 in
        --config) config_file=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    validate_config "$config_file"
    ;;
  diff)
    config_file="$CONFIG_FILE"
    while [[ $# -gt 0 ]]; do
      case $1 in
        --config) config_file=$2; shift 2 ;;
        *) usage ;;
      esac
    done
    diff_config "$config_file"
    ;;
  *)
    usage
    ;;
esac
